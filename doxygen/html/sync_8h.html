<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Snitch Runtime: sw/runtime/src/sync.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Snitch Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_01fcd3835fb4e7d9331b722d86291b65.html">sw</a></li><li class="navelem"><a class="el" href="dir_91df2be89c28e297cb810089bc4b097d.html">runtime</a></li><li class="navelem"><a class="el" href="dir_69aa9ef050bce056c0b3e6dc15051512.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sync.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file provides functions to synchronize Snitch cores.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;../../deps/riscv-opcodes/encoding.h&quot;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div>
<p><a href="sync_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad72d1461b9c336d13da30648df7a5649" id="r_ad72d1461b9c336d13da30648df7a5649"><td class="memItemLeft" align="right" valign="top"><a id="ad72d1461b9c336d13da30648df7a5649" name="ad72d1461b9c336d13da30648df7a5649"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNRT_BROADCAST_MASK</b>&#160;&#160;&#160;((SNRT_CLUSTER_NUM - 1) * SNRT_CLUSTER_OFFSET)</td></tr>
<tr class="separator:ad72d1461b9c336d13da30648df7a5649"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a39380f9772daa6eaf642d5e113b4eb36" id="r_a39380f9772daa6eaf642d5e113b4eb36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39380f9772daa6eaf642d5e113b4eb36">snrt_comm_init</a> ()</td></tr>
<tr class="memdesc:a39380f9772daa6eaf642d5e113b4eb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the communicator functions.  <br /></td></tr>
<tr class="separator:a39380f9772daa6eaf642d5e113b4eb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174856791d8bccb542df6a8f4ad0f278" id="r_a174856791d8bccb542df6a8f4ad0f278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a174856791d8bccb542df6a8f4ad0f278">snrt_comm_create</a> (uint32_t size, <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> *communicator)</td></tr>
<tr class="memdesc:a174856791d8bccb542df6a8f4ad0f278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a communicator object.  <br /></td></tr>
<tr class="separator:a174856791d8bccb542df6a8f4ad0f278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572ae0f42550fc0d5551f167f2f64a7d" id="r_a572ae0f42550fc0d5551f167f2f64a7d"><td class="memItemLeft" align="right" valign="top">volatile uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a572ae0f42550fc0d5551f167f2f64a7d">snrt_mutex</a> ()</td></tr>
<tr class="memdesc:a572ae0f42550fc0d5551f167f2f64a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a mutex variable.  <br /></td></tr>
<tr class="separator:a572ae0f42550fc0d5551f167f2f64a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321bade577f4b200a5ad8aa37f281a61" id="r_a321bade577f4b200a5ad8aa37f281a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a321bade577f4b200a5ad8aa37f281a61">snrt_mutex_acquire</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:a321bade577f4b200a5ad8aa37f281a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a mutex, blocking.  <br /></td></tr>
<tr class="separator:a321bade577f4b200a5ad8aa37f281a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25632cce8737bb2726e18ed1b4f267cf" id="r_a25632cce8737bb2726e18ed1b4f267cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25632cce8737bb2726e18ed1b4f267cf">snrt_mutex_ttas_acquire</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:a25632cce8737bb2726e18ed1b4f267cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a mutex, blocking.  <br /></td></tr>
<tr class="separator:a25632cce8737bb2726e18ed1b4f267cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c4e4b77fd2b4ce02f0235348745a57" id="r_ad0c4e4b77fd2b4ce02f0235348745a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c4e4b77fd2b4ce02f0235348745a57">snrt_mutex_release</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:ad0c4e4b77fd2b4ce02f0235348745a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously-acquired mutex.  <br /></td></tr>
<tr class="separator:ad0c4e4b77fd2b4ce02f0235348745a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179e079601e5f639db4748c5dcd70bbb" id="r_a179e079601e5f639db4748c5dcd70bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a179e079601e5f639db4748c5dcd70bbb">snrt_wake_clusters</a> (uint32_t core_mask, <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm=NULL)</td></tr>
<tr class="memdesc:a179e079601e5f639db4748c5dcd70bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake the clusters belonging to a given communicator.  <br /></td></tr>
<tr class="separator:a179e079601e5f639db4748c5dcd70bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac365cea67efa78cefdddecadf3e08d20" id="r_ac365cea67efa78cefdddecadf3e08d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a> ()</td></tr>
<tr class="memdesc:ac365cea67efa78cefdddecadf3e08d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize cores in a cluster with a hardware barrier, blocking.  <br /></td></tr>
<tr class="separator:ac365cea67efa78cefdddecadf3e08d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7099d671dde85c7bb410caffcceefa" id="r_a7e7099d671dde85c7bb410caffcceefa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a> (<a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm=NULL)</td></tr>
<tr class="memdesc:a7e7099d671dde85c7bb410caffcceefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize one core from every cluster with the others.  <br /></td></tr>
<tr class="separator:a7e7099d671dde85c7bb410caffcceefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9824f88cb2c0dfdc68e5d6052978975e" id="r_a9824f88cb2c0dfdc68e5d6052978975e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a> (<a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm)</td></tr>
<tr class="memdesc:a9824f88cb2c0dfdc68e5d6052978975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize all Snitch cores.  <br /></td></tr>
<tr class="separator:a9824f88cb2c0dfdc68e5d6052978975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009fca3dd0749c28446bf4a9f86cb211" id="r_a009fca3dd0749c28446bf4a9f86cb211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a009fca3dd0749c28446bf4a9f86cb211">snrt_partial_barrier</a> (<a class="el" href="structsnrt__barrier__t.html">snrt_barrier_t</a> *barr, uint32_t n)</td></tr>
<tr class="memdesc:a009fca3dd0749c28446bf4a9f86cb211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic software barrier.  <br /></td></tr>
<tr class="separator:a009fca3dd0749c28446bf4a9f86cb211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed7d49a94d35c044bc0701b9af191fd" id="r_a9ed7d49a94d35c044bc0701b9af191fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed7d49a94d35c044bc0701b9af191fd">snrt_global_all_to_all_reduction</a> (uint32_t value)</td></tr>
<tr class="memdesc:a9ed7d49a94d35c044bc0701b9af191fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a global sum reduction, blocking.  <br /></td></tr>
<tr class="separator:a9ed7d49a94d35c044bc0701b9af191fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5dfba8b5aa911c9af7fc253fc119ac" id="r_a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f5dfba8b5aa911c9af7fc253fc119ac">snrt_global_reduction_dma</a> (T *dst_buffer, T *src_buffer, size_t len, <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm=NULL)</td></tr>
<tr class="memdesc:a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a sum reduction among clusters, blocking.  <br /></td></tr>
<tr class="separator:a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6988e3d8671188ea63fa9a127963ebcb" id="r_a6988e3d8671188ea63fa9a127963ebcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6988e3d8671188ea63fa9a127963ebcb">snrt_wait_writeback</a> (uint32_t val)</td></tr>
<tr class="memdesc:a6988e3d8671188ea63fa9a127963ebcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure value is written back to the register file.  <br /></td></tr>
<tr class="separator:a6988e3d8671188ea63fa9a127963ebcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ac54c69b7bc3f1165277420cef710" id="r_a220ac54c69b7bc3f1165277420cef710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a220ac54c69b7bc3f1165277420cef710">snrt_enable_multicast</a> (uint32_t mask)</td></tr>
<tr class="memdesc:a220ac54c69b7bc3f1165277420cef710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable LSU multicast.  <br /></td></tr>
<tr class="separator:a220ac54c69b7bc3f1165277420cef710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3597f143342fb37d0564409eec33016" id="r_ae3597f143342fb37d0564409eec33016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3597f143342fb37d0564409eec33016">snrt_disable_multicast</a> ()</td></tr>
<tr class="memdesc:ae3597f143342fb37d0564409eec33016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable LSU multicast.  <br /></td></tr>
<tr class="separator:ae3597f143342fb37d0564409eec33016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae3a9acd2f4afcb8d04b26fea730129a8" id="r_ae3a9acd2f4afcb8d04b26fea730129a8"><td class="memItemLeft" align="right" valign="top">__thread <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a9acd2f4afcb8d04b26fea730129a8">snrt_comm_world_info</a></td></tr>
<tr class="separator:ae3a9acd2f4afcb8d04b26fea730129a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980efac657f907e499680846b99f216" id="r_a7980efac657f907e499680846b99f216"><td class="memItemLeft" align="right" valign="top"><a id="a7980efac657f907e499680846b99f216" name="a7980efac657f907e499680846b99f216"></a>
__thread <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>snrt_comm_world</b></td></tr>
<tr class="separator:a7980efac657f907e499680846b99f216"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides functions to synchronize Snitch cores. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac365cea67efa78cefdddecadf3e08d20" name="ac365cea67efa78cefdddecadf3e08d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac365cea67efa78cefdddecadf3e08d20">&#9670;&#160;</a></span>snrt_cluster_hw_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_cluster_hw_barrier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize cores in a cluster with a hardware barrier, blocking. </p>
<dl class="section note"><dt>Note</dt><dd>Synchronizes all (both DM and compute) cores. All cores must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  173</span>                                      {</div>
<div class="line"><span class="lineno">  174</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;csrr x0, 0x7C2&quot;</span> ::: <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line"><span class="lineno">  175</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a174856791d8bccb542df6a8f4ad0f278" name="a174856791d8bccb542df6a8f4ad0f278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174856791d8bccb542df6a8f4ad0f278">&#9670;&#160;</a></span>snrt_comm_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_comm_create </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> *</td>          <td class="paramname"><span class="paramname"><em>communicator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a communicator object. </p>
<p>The newly created communicator object includes the first <code>size</code> clusters. All clusters, even those which are not part of the communicator, must invoke this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of clusters to include in the communicator. </td></tr>
    <tr><td class="paramname">communicator</td><td>Pointer to the communicator object to be created. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   49</span>                                                                       {</div>
<div class="line"><span class="lineno">   50</span>    <span class="comment">// Allocate communicator struct in L1 and point to it.</span></div>
<div class="line"><span class="lineno">   51</span>    *communicator =</div>
<div class="line"><span class="lineno">   52</span>        (<a class="code hl_struct" href="structsnrt__comm__info__t.html">snrt_comm_t</a>)snrt_l1_alloc_cluster_local(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structsnrt__comm__info__t.html">snrt_comm_info_t</a>));</div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span>    <span class="comment">// Allocate barrier counter in L3 and initialize to 0. Every core invokes</span></div>
<div class="line"><span class="lineno">   55</span>    <span class="comment">// the allocation function to update its allocator, but only one core</span></div>
<div class="line"><span class="lineno">   56</span>    <span class="comment">// initializes it. A global barrier is then used to ensure all cores &quot;see&quot;</span></div>
<div class="line"><span class="lineno">   57</span>    <span class="comment">// the initialized value.</span></div>
<div class="line"><span class="lineno">   58</span>    uint32_t *barrier_ptr = (uint32_t *)snrt_l3_alloc_v2(<span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">if</span> (snrt_global_core_idx() == 0) *barrier_ptr = 0;</div>
<div class="line"><span class="lineno">   60</span>    <a class="code hl_function" href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a>();</div>
<div class="line"><span class="lineno">   61</span> </div>
<div class="line"><span class="lineno">   62</span>    <span class="comment">// Initialize communicator, pointing to the newly-allocated barrier</span></div>
<div class="line"><span class="lineno">   63</span>    <span class="comment">// counter in L3.</span></div>
<div class="line"><span class="lineno">   64</span>    (*communicator)-&gt;size = size;</div>
<div class="line"><span class="lineno">   65</span>    (*communicator)-&gt;barrier_ptr = barrier_ptr;</div>
<div class="line"><span class="lineno">   66</span>    (*communicator)-&gt;is_participant = snrt_cluster_idx() &lt; size;</div>
<div class="line"><span class="lineno">   67</span>}</div>
<div class="ttc" id="astructsnrt__comm__info__t_html"><div class="ttname"><a href="structsnrt__comm__info__t.html">snrt_comm_info_t</a></div><div class="ttdef"><b>Definition</b> sync_decls.h:14</div></div>
<div class="ttc" id="async_8h_html_a9824f88cb2c0dfdc68e5d6052978975e"><div class="ttname"><a href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a></div><div class="ttdeci">void snrt_global_barrier(snrt_comm_t comm)</div><div class="ttdoc">Synchronize all Snitch cores.</div><div class="ttdef"><b>Definition</b> sync.h:217</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a39380f9772daa6eaf642d5e113b4eb36" name="a39380f9772daa6eaf642d5e113b4eb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39380f9772daa6eaf642d5e113b4eb36">&#9670;&#160;</a></span>snrt_comm_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_comm_init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the communicator functions. </p>
<p>This function initializes the L1 allocator by calculating the end address of the heap and setting the base, end, and next pointers of the allocator.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called before using any of the allocation functions. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   37</span>{ snrt_comm_world = &amp;snrt_comm_world_info; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3597f143342fb37d0564409eec33016" name="ae3597f143342fb37d0564409eec33016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3597f143342fb37d0564409eec33016">&#9670;&#160;</a></span>snrt_disable_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_disable_multicast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable LSU multicast. </p>
<div class="fragment"><div class="line"><span class="lineno">  394</span>{ write_csr(0x7c4, 0); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a220ac54c69b7bc3f1165277420cef710" name="a220ac54c69b7bc3f1165277420cef710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220ac54c69b7bc3f1165277420cef710">&#9670;&#160;</a></span>snrt_enable_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_enable_multicast </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable LSU multicast. </p>
<p>All stores performed after this call will be multicast to all addresses specified by the address and mask pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Multicast mask value </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  389</span>{ write_csr(0x7c4, mask); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ed7d49a94d35c044bc0701b9af191fd" name="a9ed7d49a94d35c044bc0701b9af191fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed7d49a94d35c044bc0701b9af191fd">&#9670;&#160;</a></span>snrt_global_all_to_all_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t snrt_global_all_to_all_reduction </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a global sum reduction, blocking. </p>
<p>All cores participate in the reduction and synchronize globally to wait for the reduction to complete. The synchronization is performed via snrt_global_barrier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be summed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the sum reduction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Every Snitch core must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  265</span>                                                                 {</div>
<div class="line"><span class="lineno">  266</span>    <span class="comment">// Reduce cores within cluster in TCDM</span></div>
<div class="line"><span class="lineno">  267</span>    uint32_t *cluster_result = &amp;(cls()-&gt;reduction);</div>
<div class="line"><span class="lineno">  268</span>    uint32_t tmp = __atomic_fetch_add(cluster_result, value, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  269</span> </div>
<div class="line"><span class="lineno">  270</span>    <span class="comment">// Wait for writeback to ensure AMO is seen by all cores after barrier</span></div>
<div class="line"><span class="lineno">  271</span>    <a class="code hl_function" href="#a6988e3d8671188ea63fa9a127963ebcb">snrt_wait_writeback</a>(tmp);</div>
<div class="line"><span class="lineno">  272</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  273</span> </div>
<div class="line"><span class="lineno">  274</span>    <span class="comment">// Reduce DM cores across clusters in global memory</span></div>
<div class="line"><span class="lineno">  275</span>    <span class="keywordflow">if</span> (snrt_is_dm_core()) {</div>
<div class="line"><span class="lineno">  276</span>        __atomic_add_fetch(&amp;_reduction_result, *cluster_result,</div>
<div class="line"><span class="lineno">  277</span>                           __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  278</span>        <a class="code hl_function" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a>();</div>
<div class="line"><span class="lineno">  279</span>        *cluster_result = _reduction_result;</div>
<div class="line"><span class="lineno">  280</span>    }</div>
<div class="line"><span class="lineno">  281</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  282</span>    <span class="keywordflow">return</span> *cluster_result;</div>
<div class="line"><span class="lineno">  283</span>}</div>
<div class="ttc" id="async_8h_html_a6988e3d8671188ea63fa9a127963ebcb"><div class="ttname"><a href="#a6988e3d8671188ea63fa9a127963ebcb">snrt_wait_writeback</a></div><div class="ttdeci">void snrt_wait_writeback(uint32_t val)</div><div class="ttdoc">Ensure value is written back to the register file.</div><div class="ttdef"><b>Definition</b> sync.h:374</div></div>
<div class="ttc" id="async_8h_html_a7e7099d671dde85c7bb410caffcceefa"><div class="ttname"><a href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a></div><div class="ttdeci">static void snrt_inter_cluster_barrier(snrt_comm_t comm=NULL)</div><div class="ttdoc">Synchronize one core from every cluster with the others.</div><div class="ttdef"><b>Definition</b> sync.h:184</div></div>
<div class="ttc" id="async_8h_html_ac365cea67efa78cefdddecadf3e08d20"><div class="ttname"><a href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a></div><div class="ttdeci">void snrt_cluster_hw_barrier()</div><div class="ttdoc">Synchronize cores in a cluster with a hardware barrier, blocking.</div><div class="ttdef"><b>Definition</b> sync.h:173</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9824f88cb2c0dfdc68e5d6052978975e" name="a9824f88cb2c0dfdc68e5d6052978975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9824f88cb2c0dfdc68e5d6052978975e">&#9670;&#160;</a></span>snrt_global_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_global_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize all Snitch cores. </p>
<p>Synchronization is performed hierarchically. Within a cluster, cores are synchronized through a hardware barrier (see snrt_cluster_hw_barrier). Clusters are synchronized through a software barrier (see <a class="el" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters synchronize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Every Snitch core must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  217</span>                                                  {</div>
<div class="line"><span class="lineno">  218</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>    <span class="comment">// Synchronize all DM cores in software</span></div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">if</span> (snrt_is_dm_core()) {</div>
<div class="line"><span class="lineno">  222</span>        <a class="code hl_function" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a>(comm);</div>
<div class="line"><span class="lineno">  223</span>    }</div>
<div class="line"><span class="lineno">  224</span>    <span class="comment">// Synchronize cores in a cluster with the HW barrier</span></div>
<div class="line"><span class="lineno">  225</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  226</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f5dfba8b5aa911c9af7fc253fc119ac" name="a8f5dfba8b5aa911c9af7fc253fc119ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5dfba8b5aa911c9af7fc253fc119ac">&#9670;&#160;</a></span>snrt_global_reduction_dma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_global_reduction_dma </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>dst_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>src_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a sum reduction among clusters, blocking. </p>
<p>The reduction is performed in a logarithmic fashion. Half of the clusters active in every level of the binary-tree participate as as senders, the other half as receivers. Senders use the DMA to send their data to the respective receiver's destination buffer. The receiver then reduces each element in its destination buffer with the respective element in its source buffer. The result is stored in the source buffer. It then proceeds to the next level in the binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_buffer</td><td>The pointer to the calling cluster's destination buffer. </td></tr>
    <tr><td class="paramname">src_buffer</td><td>The pointer to the calling cluster's source buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data in each buffer. Only integer multiples of the number of compute cores are supported at the moment. </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters participate in the reduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination buffers must lie at the same offset in every cluster's TCDM. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  306</span>                                                               {</div>
<div class="line"><span class="lineno">  307</span>    <span class="comment">// If no communicator is given, world communicator is used as default.</span></div>
<div class="line"><span class="lineno">  308</span>    <span class="keywordflow">if</span> (comm == NULL) comm = snrt_comm_world;</div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>    <span class="comment">// If we have a single cluster, no reduction has to be done</span></div>
<div class="line"><span class="lineno">  311</span>    <span class="keywordflow">if</span> (comm-&gt;size &gt; 1) {</div>
<div class="line"><span class="lineno">  312</span>        <span class="comment">// DMA core will send compute cores&#39; data, so it must wait on it</span></div>
<div class="line"><span class="lineno">  313</span>        <span class="comment">// to be available</span></div>
<div class="line"><span class="lineno">  314</span>        snrt_fpu_fence();</div>
<div class="line"><span class="lineno">  315</span>        <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  316</span> </div>
<div class="line"><span class="lineno">  317</span>        <span class="comment">// Iterate levels in the binary reduction tree</span></div>
<div class="line"><span class="lineno">  318</span>        <span class="keywordtype">int</span> num_levels = ceil(log2(comm-&gt;size));</div>
<div class="line"><span class="lineno">  319</span>        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; num_levels; level++) {</div>
<div class="line"><span class="lineno">  320</span>            <span class="comment">// Determine whether the current cluster is an active cluster.</span></div>
<div class="line"><span class="lineno">  321</span>            <span class="comment">// An active cluster is a cluster that participates in the current</span></div>
<div class="line"><span class="lineno">  322</span>            <span class="comment">// level of the reduction tree. Every second cluster among the</span></div>
<div class="line"><span class="lineno">  323</span>            <span class="comment">// active ones is a sender.</span></div>
<div class="line"><span class="lineno">  324</span>            uint32_t is_active = (snrt_cluster_idx() % (1 &lt;&lt; level)) == 0;</div>
<div class="line"><span class="lineno">  325</span>            uint32_t is_sender = (snrt_cluster_idx() % (1 &lt;&lt; (level + 1))) != 0;</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span>            <span class="comment">// If the cluster is a sender, it sends the data in its source</span></div>
<div class="line"><span class="lineno">  328</span>            <span class="comment">// buffer to the respective receiver&#39;s destination buffer</span></div>
<div class="line"><span class="lineno">  329</span>            <span class="keywordflow">if</span> (is_active &amp;&amp; is_sender) {</div>
<div class="line"><span class="lineno">  330</span>                <span class="keywordflow">if</span> (!snrt_is_compute_core()) {</div>
<div class="line"><span class="lineno">  331</span>                    uint64_t dst = (uint64_t)dst_buffer -</div>
<div class="line"><span class="lineno">  332</span>                                   (1 &lt;&lt; level) * SNRT_CLUSTER_OFFSET;</div>
<div class="line"><span class="lineno">  333</span>                    <a class="code hl_function" href="dma_8h.html#a5742834ee8f96e897dfd5d3fe1e2fedb">snrt_dma_start_1d</a>(dst, (uint64_t)src_buffer,</div>
<div class="line"><span class="lineno">  334</span>                                      len * <span class="keyword">sizeof</span>(T));</div>
<div class="line"><span class="lineno">  335</span>                    <a class="code hl_function" href="dma_8h.html#aea9b2089c25300d67fed14450b21325a">snrt_dma_wait_all</a>();</div>
<div class="line"><span class="lineno">  336</span>                }</div>
<div class="line"><span class="lineno">  337</span>            }</div>
<div class="line"><span class="lineno">  338</span> </div>
<div class="line"><span class="lineno">  339</span>            <span class="comment">// Synchronize senders and receivers</span></div>
<div class="line"><span class="lineno">  340</span>            <a class="code hl_function" href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a>(comm);</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>            <span class="comment">// Every cluster which is not a sender performs the reduction</span></div>
<div class="line"><span class="lineno">  343</span>            <span class="keywordflow">if</span> (is_active &amp;&amp; !is_sender) {</div>
<div class="line"><span class="lineno">  344</span>                <span class="comment">// Computation is parallelized over the compute cores</span></div>
<div class="line"><span class="lineno">  345</span>                <span class="keywordflow">if</span> (snrt_is_compute_core()) {</div>
<div class="line"><span class="lineno">  346</span>                    uint32_t items_per_core =</div>
<div class="line"><span class="lineno">  347</span>                        len / snrt_cluster_compute_core_num();</div>
<div class="line"><span class="lineno">  348</span>                    uint32_t core_offset =</div>
<div class="line"><span class="lineno">  349</span>                        snrt_cluster_core_idx() * items_per_core;</div>
<div class="line"><span class="lineno">  350</span>                    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; items_per_core; i++) {</div>
<div class="line"><span class="lineno">  351</span>                        uint32_t abs_i = core_offset + i;</div>
<div class="line"><span class="lineno">  352</span>                        src_buffer[abs_i] += dst_buffer[abs_i];</div>
<div class="line"><span class="lineno">  353</span>                    }</div>
<div class="line"><span class="lineno">  354</span>                }</div>
<div class="line"><span class="lineno">  355</span>            }</div>
<div class="line"><span class="lineno">  356</span> </div>
<div class="line"><span class="lineno">  357</span>            <span class="comment">// Synchronize compute and DM cores for next tree level</span></div>
<div class="line"><span class="lineno">  358</span>            snrt_fpu_fence();</div>
<div class="line"><span class="lineno">  359</span>            <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  360</span>        }</div>
<div class="line"><span class="lineno">  361</span>    }</div>
<div class="line"><span class="lineno">  362</span>}</div>
<div class="ttc" id="adma_8h_html_a5742834ee8f96e897dfd5d3fe1e2fedb"><div class="ttname"><a href="dma_8h.html#a5742834ee8f96e897dfd5d3fe1e2fedb">snrt_dma_start_1d</a></div><div class="ttdeci">static uint32_t snrt_dma_start_1d(uint64_t dst, uint64_t src, size_t size, const uint32_t channel=0)</div><div class="ttdoc">Start an asynchronous 1D DMA transfer with 64-bit wide pointers on a specific DMA channel.</div><div class="ttdef"><b>Definition</b> dma.h:31</div></div>
<div class="ttc" id="adma_8h_html_aea9b2089c25300d67fed14450b21325a"><div class="ttname"><a href="dma_8h.html#aea9b2089c25300d67fed14450b21325a">snrt_dma_wait_all</a></div><div class="ttdeci">static void snrt_dma_wait_all(const uint32_t channel=0)</div><div class="ttdoc">Block until a specific DMA channel is idle.</div><div class="ttdef"><b>Definition</b> dma.h:239</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e7099d671dde85c7bb410caffcceefa" name="a7e7099d671dde85c7bb410caffcceefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7099d671dde85c7bb410caffcceefa">&#9670;&#160;</a></span>snrt_inter_cluster_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void snrt_inter_cluster_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize one core from every cluster with the others. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters synchronize.</td></tr>
  </table>
  </dd>
</dl>
<p>Implemented as a software barrier. </p><dl class="section note"><dt>Note</dt><dd>One core per cluster participating in the barrier must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  184</span>                                                                       {</div>
<div class="line"><span class="lineno">  185</span>    <span class="comment">// If no communicator is given, world communicator is used as default.</span></div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">if</span> (comm == NULL) comm = snrt_comm_world;</div>
<div class="line"><span class="lineno">  187</span> </div>
<div class="line"><span class="lineno">  188</span>    <span class="comment">// If the current cluster is not a participant, return immediately.</span></div>
<div class="line"><span class="lineno">  189</span>    <span class="keywordflow">if</span> (!comm-&gt;is_participant) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  190</span> </div>
<div class="line"><span class="lineno">  191</span>    <span class="comment">// Clusters participating in the barrier increment a shared counter.</span></div>
<div class="line"><span class="lineno">  192</span>    uint32_t cnt = __atomic_add_fetch(comm-&gt;barrier_ptr, 1, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>    <span class="comment">// All but the last cluster arriving on the barrier enter WFI. The last</span></div>
<div class="line"><span class="lineno">  195</span>    <span class="comment">// cluster resets the counter for the next barrier (if any) and multicasts</span></div>
<div class="line"><span class="lineno">  196</span>    <span class="comment">// an interrupt to wake up the other clusters.</span></div>
<div class="line"><span class="lineno">  197</span>    <span class="keywordflow">if</span> (cnt == comm-&gt;size) {</div>
<div class="line"><span class="lineno">  198</span>        *(comm-&gt;barrier_ptr) = 0;</div>
<div class="line"><span class="lineno">  199</span>        <a class="code hl_function" href="#a179e079601e5f639db4748c5dcd70bbb">snrt_wake_clusters</a>(1 &lt;&lt; snrt_cluster_core_idx(), comm);</div>
<div class="line"><span class="lineno">  200</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  201</span>        snrt_wfi();</div>
<div class="line"><span class="lineno">  202</span>        <span class="comment">// Clear interrupt for next barrier</span></div>
<div class="line"><span class="lineno">  203</span>        snrt_int_clr_mcip();</div>
<div class="line"><span class="lineno">  204</span>    }</div>
<div class="line"><span class="lineno">  205</span>}</div>
<div class="ttc" id="async_8h_html_a179e079601e5f639db4748c5dcd70bbb"><div class="ttname"><a href="#a179e079601e5f639db4748c5dcd70bbb">snrt_wake_clusters</a></div><div class="ttdeci">void snrt_wake_clusters(uint32_t core_mask, snrt_comm_t comm=NULL)</div><div class="ttdoc">Wake the clusters belonging to a given communicator.</div><div class="ttdef"><b>Definition</b> sync.h:132</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a572ae0f42550fc0d5551f167f2f64a7d" name="a572ae0f42550fc0d5551f167f2f64a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572ae0f42550fc0d5551f167f2f64a7d">&#9670;&#160;</a></span>snrt_mutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t * snrt_mutex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a mutex variable. </p>
<div class="fragment"><div class="line"><span class="lineno">   76</span>{ <span class="keywordflow">return</span> &amp;_snrt_mutex; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a321bade577f4b200a5ad8aa37f281a61" name="a321bade577f4b200a5ad8aa37f281a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321bade577f4b200a5ad8aa37f281a61">&#9670;&#160;</a></span>snrt_mutex_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_acquire </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a mutex, blocking. </p>
<p>Test-and-set (TAS) implementation of a lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmtx</td><td>A pointer to a variable which can be used as a mutex, i.e. to which all cores have a reference and at a memory location to which atomic accesses can be made. This can be declared e.g. as <code>static volatile uint32_t mtx = 0;</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   86</span>                                                        {</div>
<div class="line"><span class="lineno">   87</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(</div>
<div class="line"><span class="lineno">   88</span>        <span class="stringliteral">&quot;li            t0,1          # t0 = 1\n&quot;</span></div>
<div class="line"><span class="lineno">   89</span>        <span class="stringliteral">&quot;1:\n&quot;</span></div>
<div class="line"><span class="lineno">   90</span>        <span class="stringliteral">&quot;  amoswap.w.aq  t0,t0,(%0)   # t0 = oldlock &amp; lock = 1\n&quot;</span></div>
<div class="line"><span class="lineno">   91</span>        <span class="stringliteral">&quot;  bnez          t0,1b      # Retry if previously set)\n&quot;</span></div>
<div class="line"><span class="lineno">   92</span>        : <span class="stringliteral">&quot;+r&quot;</span>(pmtx)</div>
<div class="line"><span class="lineno">   93</span>        :</div>
<div class="line"><span class="lineno">   94</span>        : <span class="stringliteral">&quot;t0&quot;</span>);</div>
<div class="line"><span class="lineno">   95</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0c4e4b77fd2b4ce02f0235348745a57" name="ad0c4e4b77fd2b4ce02f0235348745a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c4e4b77fd2b4ce02f0235348745a57">&#9670;&#160;</a></span>snrt_mutex_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_release </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a previously-acquired mutex. </p>
<div class="fragment"><div class="line"><span class="lineno">  119</span>                                                        {</div>
<div class="line"><span class="lineno">  120</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;amoswap.w.rl  x0,x0,(%0)   # Release lock by storing 0\n&quot;</span></div>
<div class="line"><span class="lineno">  121</span>                 : <span class="stringliteral">&quot;+r&quot;</span>(pmtx));</div>
<div class="line"><span class="lineno">  122</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a25632cce8737bb2726e18ed1b4f267cf" name="a25632cce8737bb2726e18ed1b4f267cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25632cce8737bb2726e18ed1b4f267cf">&#9670;&#160;</a></span>snrt_mutex_ttas_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_ttas_acquire </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a mutex, blocking. </p>
<p>Same as snrt_mutex_acquire but acquires the lock using a test and test-and-set (TTAS) strategy. </p>
<div class="fragment"><div class="line"><span class="lineno">  102</span>                                                             {</div>
<div class="line"><span class="lineno">  103</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(</div>
<div class="line"><span class="lineno">  104</span>        <span class="stringliteral">&quot;1:\n&quot;</span></div>
<div class="line"><span class="lineno">  105</span>        <span class="stringliteral">&quot;  lw t0, 0(%0)\n&quot;</span></div>
<div class="line"><span class="lineno">  106</span>        <span class="stringliteral">&quot;  bnez t0, 1b\n&quot;</span></div>
<div class="line"><span class="lineno">  107</span>        <span class="stringliteral">&quot;  li t0,1          # t0 = 1\n&quot;</span></div>
<div class="line"><span class="lineno">  108</span>        <span class="stringliteral">&quot;2:\n&quot;</span></div>
<div class="line"><span class="lineno">  109</span>        <span class="stringliteral">&quot;  amoswap.w.aq  t0,t0,(%0)   # t0 = oldlock &amp; lock = 1\n&quot;</span></div>
<div class="line"><span class="lineno">  110</span>        <span class="stringliteral">&quot;  bnez          t0,2b      # Retry if previously set)\n&quot;</span></div>
<div class="line"><span class="lineno">  111</span>        : <span class="stringliteral">&quot;+r&quot;</span>(pmtx)</div>
<div class="line"><span class="lineno">  112</span>        :</div>
<div class="line"><span class="lineno">  113</span>        : <span class="stringliteral">&quot;t0&quot;</span>);</div>
<div class="line"><span class="lineno">  114</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a009fca3dd0749c28446bf4a9f86cb211" name="a009fca3dd0749c28446bf4a9f86cb211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009fca3dd0749c28446bf4a9f86cb211">&#9670;&#160;</a></span>snrt_partial_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_partial_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__barrier__t.html">snrt_barrier_t</a> *</td>          <td class="paramname"><span class="paramname"><em>barr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic software barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barr</td><td>pointer to a barrier variable. </td></tr>
    <tr><td class="paramname">n</td><td>number of harts that have to enter before released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Exactly the specified number of harts must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  235</span>                                                                   {</div>
<div class="line"><span class="lineno">  236</span>    <span class="comment">// Remember previous iteration</span></div>
<div class="line"><span class="lineno">  237</span>    uint32_t prev_it = barr-&gt;iteration;</div>
<div class="line"><span class="lineno">  238</span>    uint32_t cnt = __atomic_add_fetch(&amp;barr-&gt;cnt, 1, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>    <span class="comment">// Increment the barrier counter</span></div>
<div class="line"><span class="lineno">  241</span>    <span class="keywordflow">if</span> (cnt == n) {</div>
<div class="line"><span class="lineno">  242</span>        barr-&gt;cnt = 0;</div>
<div class="line"><span class="lineno">  243</span>        __atomic_add_fetch(&amp;barr-&gt;iteration, 1, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  244</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  245</span>        <span class="comment">// Some threads have not reached the barrier --&gt; Let&#39;s wait</span></div>
<div class="line"><span class="lineno">  246</span>        <span class="keywordflow">while</span> (prev_it == barr-&gt;iteration)</div>
<div class="line"><span class="lineno">  247</span>            ;</div>
<div class="line"><span class="lineno">  248</span>    }</div>
<div class="line"><span class="lineno">  249</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6988e3d8671188ea63fa9a127963ebcb" name="a6988e3d8671188ea63fa9a127963ebcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6988e3d8671188ea63fa9a127963ebcb">&#9670;&#160;</a></span>snrt_wait_writeback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_wait_writeback </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure value is written back to the register file. </p>
<p>This function introduces a RAW dependency on val to stall the core until val is written back to the register file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The variable we want to wait on. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  374</span>                                              {</div>
<div class="line"><span class="lineno">  375</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mv %0, %0&quot;</span> : <span class="stringliteral">&quot;+r&quot;</span>(val)::);</div>
<div class="line"><span class="lineno">  376</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a179e079601e5f639db4748c5dcd70bbb" name="a179e079601e5f639db4748c5dcd70bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179e079601e5f639db4748c5dcd70bbb">&#9670;&#160;</a></span>snrt_wake_clusters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_wake_clusters </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>core_mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wake the clusters belonging to a given communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters to wake up. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  132</span>                                                                            {</div>
<div class="line"><span class="lineno">  133</span>    <span class="comment">// If no communicator is given, world communicator is used as default.</span></div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordflow">if</span> (comm == NULL) comm = snrt_comm_world;</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span><span class="preprocessor">#ifdef SNRT_SUPPORTS_MULTICAST</span></div>
<div class="line"><span class="lineno">  137</span>    <span class="comment">// Multicast cluster interrupt to every other cluster&#39;s core</span></div>
<div class="line"><span class="lineno">  138</span>    <span class="comment">// Note: we need to address another cluster&#39;s address space</span></div>
<div class="line"><span class="lineno">  139</span>    <span class="comment">//       because the cluster XBAR has not been extended to support</span></div>
<div class="line"><span class="lineno">  140</span>    <span class="comment">//       multicast yet. We address the second cluster, if we are the</span></div>
<div class="line"><span class="lineno">  141</span>    <span class="comment">//       first cluster, and the first cluster otherwise.</span></div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">if</span> (snrt_cluster_num() &gt; 0) {</div>
<div class="line"><span class="lineno">  143</span>        <span class="keyword">volatile</span> snitch_cluster_t *cluster;</div>
<div class="line"><span class="lineno">  144</span>        <span class="keywordflow">if</span> (snrt_cluster_idx() == 0)</div>
<div class="line"><span class="lineno">  145</span>            cluster = snrt_cluster(1);</div>
<div class="line"><span class="lineno">  146</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  147</span>            cluster = snrt_cluster(0);</div>
<div class="line"><span class="lineno">  148</span><span class="preprocessor">#pragma clang diagnostic push</span></div>
<div class="line"><span class="lineno">  149</span><span class="preprocessor">#pragma clang diagnostic ignored &quot;-Waddress-of-packed-member&quot;</span></div>
<div class="line"><span class="lineno">  150</span>        uint32_t *addr = (uint32_t *)&amp;(cluster-&gt;peripheral_reg.cl_clint_set.w);</div>
<div class="line"><span class="lineno">  151</span><span class="preprocessor">#pragma clang diagnostic pop</span></div>
<div class="line"><span class="lineno">  152</span>        uint32_t mcast_mask = ((comm-&gt;size) - 1) * SNRT_CLUSTER_OFFSET;</div>
<div class="line"><span class="lineno">  153</span>        <a class="code hl_function" href="#a220ac54c69b7bc3f1165277420cef710">snrt_enable_multicast</a>(mcast_mask);</div>
<div class="line"><span class="lineno">  154</span>        *addr = core_mask;</div>
<div class="line"><span class="lineno">  155</span>        <a class="code hl_function" href="#ae3597f143342fb37d0564409eec33016">snrt_disable_multicast</a>();</div>
<div class="line"><span class="lineno">  156</span>    }</div>
<div class="line"><span class="lineno">  157</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  158</span>    <span class="comment">// Wake clusters sequentially</span></div>
<div class="line"><span class="lineno">  159</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; comm-&gt;size; i++) {</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">if</span> (snrt_cluster_idx() != i) {</div>
<div class="line"><span class="lineno">  161</span>            snrt_cluster(i)-&gt;peripheral_reg.cl_clint_set.f.cl_clint_set =</div>
<div class="line"><span class="lineno">  162</span>                core_mask;</div>
<div class="line"><span class="lineno">  163</span>        }</div>
<div class="line"><span class="lineno">  164</span>    }</div>
<div class="line"><span class="lineno">  165</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  166</span>}</div>
<div class="ttc" id="async_8h_html_a220ac54c69b7bc3f1165277420cef710"><div class="ttname"><a href="#a220ac54c69b7bc3f1165277420cef710">snrt_enable_multicast</a></div><div class="ttdeci">void snrt_enable_multicast(uint32_t mask)</div><div class="ttdoc">Enable LSU multicast.</div><div class="ttdef"><b>Definition</b> sync.h:389</div></div>
<div class="ttc" id="async_8h_html_ae3597f143342fb37d0564409eec33016"><div class="ttname"><a href="#ae3597f143342fb37d0564409eec33016">snrt_disable_multicast</a></div><div class="ttdeci">void snrt_disable_multicast()</div><div class="ttdoc">Disable LSU multicast.</div><div class="ttdef"><b>Definition</b> sync.h:394</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae3a9acd2f4afcb8d04b26fea730129a8" name="ae3a9acd2f4afcb8d04b26fea730129a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a9acd2f4afcb8d04b26fea730129a8">&#9670;&#160;</a></span>snrt_comm_world_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__thread <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_info_t</a> snrt_comm_world_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   14</span>                                                 {</div>
<div class="line"><span class="lineno">   15</span>    .barrier_ptr = &amp;(_snrt_barrier.cnt),</div>
<div class="line"><span class="lineno">   16</span>    .size = SNRT_CLUSTER_NUM,</div>
<div class="line"><span class="lineno">   17</span>    .is_participant = 1};</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
